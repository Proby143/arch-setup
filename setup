#!/bin/bash

clear
setfont Lat2-Terminus16.psfu.gz
dialog --title "Welcome to Arch Linux Installer" \
  --ok-label "Begin Installation" --msgbox "Navigating the installer is \
easy.\nYou may select options using the ARROW keys and SPACE or \
ENTER.\nAlternate keys may also be used: '+', '-', and TAB." 7 70

# Proceed with installation only if there is an internet connection
check_connection() {
  # Only check that the web page is available, don't download the contents
  wget -q --spider archlinux.org
  if [ $? -ne 0 ]; then 
    dialog --title "Connect to the Internet" \
      --msgbox "The installer was unable to detect a working internet \
connection. The installation media supports wired network devices on \
boot. Make sure the cable is plugged in. Wireless users should use the \
'wifi-menu' command and follow the on-screen instructions to connect to \
a wireless connection.\n\nOnce you have a working internet connection, \
retry running the installer." 11 80
    reset ; exit
  fi
}

# Unmount all partitions and check if there are any active LVM or crypt devices
check_device_status() {
  if mountpoint -q /mnt; then
    umount -R /mnt
  fi

  if free | awk '/^Swap:/ {exit !$2}'; then
    swapoff -a
  fi

  LVM_STATUS=$(lvdisplay | grep "LV Status" | sort -u | awk '{print $3}')
  if [ "$LVM_STATUS" = "available" ]; then
    for vgroup in $(lvdisplay | grep "VG Name" | sort -u | awk '{print $3}');
    do
      vgchange -f -a n $vgroup &> /dev/null
      vgremove -f $vgroup &> /dev/null
    done
  fi

  if [ "$(dmsetup ls --target crypt)" != "No devices found" ]; then
    dialog --title "WARNING: Encrypted Device In Use" --defaultno \
      --yesno "The installer has detected that there is an encrypted device \
that is currently in use.\n\nThis message may appear if you chose the \
'Encrypted' option during partitioning, but did not complete the \
installation or you changed to a different partition layout.\n\nIf the above \
message is true, then you can ignore this warning and select 'Yes' to proceed \
with the installation. If you have any active encrypted devices that were not \
created by the installer, you should select 'No'.\n\nWould you like the \
installer to close all active encrypted devices and proceed with the \
installation?" 18 75

    if [ $? -eq 0 ]; then
      for active_crypt in "$(dmsetup ls --target crypt | awk '{print $1}')"; do
        cryptsetup close "$active_crypt"
      done
    else
      dialog --title "ERROR: Unable to Partition $DISK" \
        --msgbox "The installer encountered an error while partitioning \
$DISK.\n\nIf you have any active encrypted devices, please close them before \
running the installer. If you keep encountering this error, please reboot \
your machine and try again." 10 70
      reset ; exit
    fi
  fi
}

# Prompt the user to set their keyboard layout
set_keymap() {
  while true; do
    KEYMAP=$(dialog --title "Set the Keyboard Layout" --nocancel \
      --default-item "us" --menu "Select a keymap that corresponds to your \
keyboard layout. Choose 'other' if your keymap is not listed. If you are \
unsure, the default is 'us' (United States/QWERTY).\n\nKeymap:" 28 57 16 \
"br-abnt2" "Brazilian Portuguese" \
"cf" "Canadian-French" \
"colemak" "Colemak (US)" \
"dvorak" "Dvorak (US)" \
"fr-latin1" "French" \
"de-latin1" "German" \
"it" "Italian" \
"jp" "Japanese" \
"pt-latin9" "Portuguese" \
"ru4" "Russian" \
"es" "Spanish" \
"la-latin1" "Spanish Latinoamerican" \
"sv-latin1" "Swedish" \
"us" "United States" \
"uk" "United Kingdom" \
"other" "View all available keymaps" 3>&1 1>&2 2>&3)

    if [ "$KEYMAP" = "other" ]; then
      keymaps=()
      for map in $(localectl list-keymaps); do
        keymaps+=("$map" "")
      done
    
      KEYMAP=$(dialog --title "Set the Keyboard Layout" --cancel-label "Back" \
        --menu "Select a keymap that corresponds to your keyboard layout. The \
default is 'us' (United States/QWERTY)." 30 60 25 \
"${keymaps[@]}" 3>&1 1>&2 2>&3)

      if [ $? -eq 0 ]; then
        break
      fi
    else
      break
    fi
  done
}

# Prompt the user to set the system locale
set_locale() {
  while true; do
    LOCALE=$(dialog --title "Set the System Locale" --nocancel \
      --default-item "en_US.UTF-8" --menu "Select a locale that corresponds \
to your language and region. The locale you select will define the language \
used by the system and other region specific information. Choose 'other' if \
your language and/or region is not listed. If you are unsure, the default is \
'en_US.UTF-8'.\n\nLocale:" 30 65 16 \
"zh_CN.UTF-8" "Chinese (Simplified)" \
"en_AU.UTF-8" "English (Australia)" \
"en_CA.UTF-8" "English (Canada)" \
"en_US.UTF-8" "English (United States)" \
"en_GB.UTF-8" "English (Great Britain)" \
"fr_FR.UTF-8" "French (France)" \
"de_DE.UTF-8" "German (Germany)" \
"it_IT.UTF-8" "Italian (Italy)" \
"ja_JP.UTF-8" "Japanese (Japan)" \
"pt_BR.UTF-8" "Portuguese (Brazil)" \
"pt_PT.UTF-8" "Portuguese (Portugal)" \
"ru_RU.UTF-8" "Russian (Russia)" \
"es_MX.UTF-8" "Spanish (Mexico)" \
"es_ES.UTF-8" "Spanish (Spain)" \
"sv_SE.UTF-8" "Swedish (Sweden)" \
"other" "View all available locales" 3>&1 1>&2 2>&3)

    if [ "$LOCALE" = "other" ]; then
      locales=()
      for loc in $(egrep "^#?[a-z].*UTF-8" /etc/locale.gen | \
        sed -e 's/#//' -e 's/\s.*$//'); do
        locales+=("$loc" "")
      done

      LOCALE=$(dialog --title "Set the System Locale" --cancel-label "Back" \
        --menu "Select a locale that corresponds to your language and region. \
The locale you select will define the language used by the system and other
region specific information. If you are unsure, the default is \
'en_US.UTF-8'.\n\nLocale:" 30 65 16 \
"${locales[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -eq 0 ]; then
          break
      fi
    else
      break
    fi
  done
}

# Prompt the user to set the system time zone
set_timezone() {
  regions=()
  for region in $(find /usr/share/zoneinfo -mindepth 1 -maxdepth 1 -type d \
    ! -path "*posix" ! -path "*right" -printf '%f\n' | sort); do
    regions+=("$region" "")
  done
  regions+=("other" "")

  while true; do
    ZONE=$(dialog --title "Set the Time Zone" --nocancel \
      --menu "Select your time zone.\nIf your region is not listed, select \
'other'.\n\nTime zone:" 27 50 17 \
"${regions[@]}" 3>&1 1>&2 2>&3)

    if [ "$ZONE" != "other" ]; then
      zone_regions=()
      for zone_region in $(find /usr/share/zoneinfo/"${ZONE}" \
        -mindepth 1 -maxdepth 1 -printf '%f\n' | sort); do
        zone_regions+=("$zone_region" "")
      done

      SUBZONE=$(dialog --title "Set the Time Zone" --cancel-label "Back" \
        --menu "Select your time zone.\n\nTime zone:" 27 50 17 \
"${zone_regions[@]}" 3>&1 1>&2 2>&3)

      if [ $? -eq 0 ]; then
        if [ -d /usr/share/zoneinfo/"${ZONE}/${SUBZONE}" ]; then
          subzone_regions=()
          for subzone_region in $(find /usr/share/zoneinfo/"${ZONE}/${SUBZONE}" \
            -mindepth 1 -maxdepth 1 -printf '%f\n' | sort); do
            subzone_regions+=("$subzone_region" "")
          done
          
          SUBZONE_SUBREGION=$(dialog --title "Set the Time Zone" \
            --cancel-label "Back" \
            --menu "Select your time zone.\n\nTime zone:" 27 50 17 \
"${subzone_regions[@]}" 3>&1 1>&2 2>&3)

          if [ $? -eq 0 ]; then
            ZONE="${ZONE}/${SUBZONE}/${SUBZONE_SUBREGION}"
            break
          fi
        else
          ZONE="${ZONE}/${SUBZONE}"
          break
        fi
      fi
    else
      for other_region in $(ls -p /usr/share/zoneinfo | egrep -v \
        '/$|iso3166.tab|leapseconds|posixrules|tzdata.zi|zone.tab|zone1970.tab');
      do
        other_regions+=("$other_region" "")
      done

      ZONE=$(dialog --title "Set the Time Zone" --cancel-label "Back" \
        --menu "Select your time zone.\n\nTime zone:" 27 50 17 \
"${other_regions[@]}" 3>&1 1>&2 2>&3)

      if [ $? -eq 0 ]; then
        ZONE="${ZONE}"
        break
      fi
    fi
  done
}

# Prompt the user to set the hostname for the system
set_hostname() {
  while true; do
    HOST_NAME=$(dialog --title "Set the Hostname" --nocancel \
      --inputbox "Please enter the hostname for this system.\n\nThe hostname \
is a single word that identifies your system to the network.\n\nHostname:" \
12 80 "arch" 3>&1 1>&2 2>&3)

    if [ $(printf -- "$HOST_NAME" | egrep -o "^[a-zA-Z0-9-]{1,63}$") ] && \
      [ "${HOST_NAME:0:1}" != "-" ] && \
      [ "${HOST_NAME: -1}" != "-" ]; then
      break
    else
      dialog --title "ERROR: Invalid Hostname Format" \
        --msgbox "You entered an invalid hostname.\n\nA valid hostname may \
contain only the numbers 0-9, upper and lowercase letters (A-Z and a-z), and \
the minus sign. It must be at most 63 characters long, and may not begin \
or end with a minus sign." 9 75
    fi
  done
}

# Prompt the user to create a password for the superuser account
set_root_passwd(){
  inputs_match=false
  while ! $inputs_match; do
    input=$(dialog --title "Set the Root Password" --clear --stdout --nocancel \
      --insecure --passwordbox "Please enter a password for 'root', the \
system administrative account.\n\nRoot password:" 10 75)
    confirm_input=$(dialog --title "Set the Root Password" --clear --stdout \
      --insecure --passwordbox "Re-enter password to verify:" 8 55)

    if [ -z "$input" ]; then
      dialog --title "ERROR: Empty Password" \
        --msgbox "You are not allowed to have an empty password." 5 55
    elif [ "$input" != "$confirm_input" ]; then
      dialog --title "ERROR: Passwords Do No Match" \
        --msgbox "The two passwords you entered did not match." 5 55
    else
      root_passwd="$input"
      inputs_match=true
    fi
  done
}

# Prompt the user to create an unprivileged user account
create_user() {
  while true; do
    FULL_NAME=$(dialog --title "Create a User Account" --nocancel \
      --inputbox "The installer will create a user account for you. This is \
the main user account that you will login to and use for non-administrative \
activities.\n\nPlease enter the real name for this user. This information \
will be used for any program that uses the user's real name such as email. \
Entering your full name here is recommended; however, it may be left \
blank.\n\nFull name for the new user:" 15 80 3>&1 1>&2 2>&3)

    USER_NAME=$(dialog --title "Create a User Account" \
     --cancel-label "Back" --inputbox "Please enter a username for the new \
account.\n\nThe username should start with a lower-case letter, which can be \
followed by any combination of numbers, more lower-case letters, or the dash \
symbol.\n\nUsername for your account:" 13 80 3>&1 1>&2 2>&3)
    if [ $? -eq 0 ]; then
      if [ $(printf -- "$USER_NAME" | egrep -o "^[a-z][a-z0-9-]*$") ] && \
        [ "${#USER_NAME}" -lt 33 ]; then
        if grep -Fxq "$USER_NAME" reserved_usernames; then
          dialog --title "ERROR: Reserved Username" \
            --msgbox "The username you entered ($USER_NAME) is reserved for \
use by the system. Please select a different one." 6 70
        else 
          inputs_match=false
          while ! $inputs_match; do
            input=$(dialog --title "Set the Password for $USER_NAME" --clear \
              --stdout --nocancel --insecure --passwordbox "Please enter a \
password for '$USER_NAME'.\n\nChoose a password for the new user:" 10 70)
            confirm_input=$(dialog --title "Set the Password for $USER_NAME" \
              --clear --stdout --insecure \
              --passwordbox "Re-enter password to verify:" 8 55)

            if [ -z "$input" ]; then
              dialog --title "ERROR: Empty Password" \
                --msgbox "You are not allowed to have an empty password." 5 55
            elif [ "$input" != "$confirm_input" ]; then
              dialog --title "ERROR: Passwords Do No Match" \
                --msgbox "The two passwords you entered did not match." 5 55
            else
              user_passwd="$input"
              inputs_match=true
            fi
          done
          break
        fi
      else
        dialog --title "ERROR: Invalid Username Format" \
          --msgbox "You entered an invalid username.\n\nThe username must \
start with a lower-case letter, which can be followed by any combination of \
numbers, more lower-case letters, or the dash symbol, and must be no more \
than 32 characters long." 9 80
      fi
    fi
  done
}

# Prepare the user's selected disk for partitioning
prepare_disk() {
  # List all available block devices excluding 'rom' and 'loop'
  BLOCK_DEVICES=()
  for device in $(lsblk -d -n -p -r -e 7,11 -o NAME); do
    device_size=$(lsblk -d -n -r -o SIZE "$device")
    BLOCK_DEVICES+=("$device" "$device_size")
  done

  while true; do
    PARTITION_LAYOUT=$(dialog --title "Partition the Disks" \
      --cancel-label "Exit to Menu" \
      --menu "The installer will now automatically partition a disk for you. \
If you have no preference or are unsure about which partition layout to \
choose, the 'Basic' layout is the simplest and should be enough for most use \
cases.\n\nPartition layout:" 16 80 3 \
"Basic" "Use entire disk" \
"LVM" "Use entire disk and set up LVM" \
"Encrypted" "Use entire disk and set up encrypted LVM" 3>&1 1>&2 2>&3)

    if [ $? -eq 0 ]; then
      DISK=$(dialog --title "Set the Installation Disk" --cancel-label "Back" \
        --menu "Select the disk for Arch Linux to be installed on. Note that \
the disk you select will be erased, but not until you have confirmed the \
changes.\n\nDisk to partition:" 20 55 5 \
"${BLOCK_DEVICES[@]}" 3>&1 1>&2 2>&3)

      if [ $? -eq 0 ]; then
        # NVME devices have different naming conventions for partitions 
        if [[ $DISK == *"nvme"* ]]; then
          PREFIX="p"
        fi

        FILE_SYSTEM=$(dialog --title "Set the Filesystem for $DISK_ROOT" \
          --nocancel --menu "Select the type of filesystem to use for the \
specified device. If you are unsure, 'ext4' is the default.\n\nFilesystem \
type:" 15 68 5 \
"ext4" "Ext4 journaling filesystem" \
"ext3" "Ext3 journaling filesystem" \
"ext2" "Standard Linux Ext2 filesystem" \
"btrfs" "Btrfs Copy-on-Write B-tree filesystem" \
"xfs" "SGI's journaling filesystem" 3>&1 1>&2 2>&3)

        dialog --title "Create a Swap Partition" \
          --yesno "Would you like to create an optional swap partition? If \
you are unsure, it is recommended to create one." 6 57 

        if [ $? -eq 0 ]; then
          # Get the amount of RAM in the system to use as default swap size
          MEM_TOTAL=$(free --giga | awk '/^Mem:/{print $2}')
          if [ "$MEM_TOTAL" = "0" ]; then
            MEM_TOTAL="${MEM_TOTAL}M"
          else
            MEM_TOTAL="${MEM_TOTAL}G"
          fi

          while true; do
            SWAP=$(dialog --title "Allocate Swap Space" \
              --inputbox "Specify how much swap space to allocate. If you are \
unsure, the default is to have swap space equal to the amount of RAM in your \
system.\n\nSwap partition size (use 'M' for MiB or 'G' for GiB):" 11 80 \
"$MEM_TOTAL" 3>&1 1>&2 2>&3)
            
            if [ $? -eq 0 ]; then
              disk_size_bytes=$(lsblk -b -d -n -o SIZE $DISK)
              disk_size_mibs=$((disk_size_bytes / 1024 / 1024))
              disk_size_gibs=$((disk_size_mibs / 1024))
              swap_size=$(printf "$SWAP" | tr -c -d '[:digit:]')

              # Input validation for swap size
              if [ "$(printf "$SWAP" | egrep -o "^[0-9]+[MG]$")" ]; then
                if [ "${SWAP: -1}" = "M" ] && \
                  [ "$swap_size" -lt $(( $disk_size_mibs - 2048 )) ]; then
                  swap_enabled=true
                  break
                elif [ "${SWAP: -1}" = "G" ] && \
                  [ "$swap_size" -lt $(( $disk_size_gibs - 2 )) ]; then
                  swap_enabled=true
                  break
                else
                  dialog --title "ERROR: Not Enough Disk Space" \
                    --msgbox "The amount you entered exceeds the amount of \
space available on the disk. Note that the installer sets aside an additional \
2 GiB to have enough space for the base installation." 8 60
                fi
              else
                dialog --title "ERROR: Invalid Format" \
                  --msgbox "You entered an invalid format. Make sure to use \
'M' for 'MiB' or 'G' for 'GiB'." 6 60
              fi
            else
              swap_enabled=false
              SWAP="none"
              break
            fi
          done
        else
          swap_enabled=false
          SWAP="none"
        fi

        dialog --title "Confirm the Partition Layout for $DISK" --defaultno \
          --yesno "WARNING: All data on the selected disk will be lost! Make \
sure to review your changes before continuing.\n\nDisk to partition: \
$DISK\nPartition layout: $PARTITION_LAYOUT\nFilesystem type: \
$FILE_SYSTEM\nSwap size: $SWAP\n\nAre you sure you want to write the \
changes to the disk?" 13 60  
        if [ $? -eq 0 ]; then
          check_device_status
          case "$PARTITION_LAYOUT" in
            "Basic") create_basic_layout ;;
            "LVM"|"Encrypted") create_lvm_layout ;;
          esac
          break
        else
          main_menu
        fi
      fi
    else
      main_menu
    fi
  done
}

# Partition the selected disk using the simplest partition layout
# UEFI systems use GPT partitioning and BIOS/CSM systems use MBR
create_basic_layout() {
  if [ -d /sys/firmware/efi ]; then
    BOOT_PART="${DISK}${PREFIX}1"
    ROOT_PART="${DISK}${PREFIX}2"
    parted -s $DISK mklabel gpt
    if $swap_enabled; then
      sgdisk -n 1:0:+512M -n 2:0:-$SWAP -n 3:-$SWAP:-0 -t 1:ef00 -t 2:8300 \
        -t 3:8200 $DISK &> /dev/null
      SWAP_PART="${DISK}${PREFIX}3"
      mkswap $SWAP_PART &> /dev/null
      swapon $SWAP_PART
    else
      sgdisk -n 1:0:+512M -n 2:0:0 -t 1:ef00 -t 2:8300 $DISK &> /dev/null
    fi
    mkfs.fat -F32 $BOOT_PART &> /dev/null
  else
    ROOT_PART="${DISK}${PREFIX}1"
    parted -s $DISK mklabel msdos
    if $swap_enabled; then
      echo -e "n\np\n1\n\n-${SWAP}\nn\np\n2\n\n\nt\n2\n82\nw" | \
        fdisk $DISK &> /dev/null
      SWAP_PART="${DISK}${PREFIX}2"
      mkswap $SWAP_PART &> /dev/null
      swapon $SWAP_PART
    else
      echo -e "n\np\n1\n\n\nw" | fdisk $DISK &> /dev/null
    fi
  fi
  
  case "$FILE_SYSTEM" in
    btrfs|xfs) mkfs."$FILE_SYSTEM" -f "$ROOT_PART" &> /dev/null ;;
    *) mkfs."$FILE_SYSTEM" "$ROOT_PART" &> /dev/null ;;
  esac
  mount $ROOT_PART /mnt
  if [ -d /sys/firmware/efi ]; then
    mkdir /mnt/boot
    mount $BOOT_PART /mnt/boot
  fi
}

# Partition the selected disk and prepare for Arch installation on LVM
create_lvm_layout() {
  if [ -d /sys/firmware/efi ]; then
    BOOT_PART="${DISK}${PREFIX}1"
    ROOT_PART="${DISK}${PREFIX}2"
    parted -s $DISK mklabel gpt
    sgdisk -n 1:0:+512M -n 2:0:0 -t 1:ef00 -t 2:8e00 $DISK &> /dev/null
    mkfs.fat -F32 $BOOT_PART &> /dev/null
  else
    ROOT_PART="${DISK}${PREFIX}1"
    parted -s $DISK mklabel msdos
    echo -e "n\np\n1\n\n\nt\n8e\nw" | fdisk $DISK &> /dev/null
  fi

  LVM_GROUP="arch"
  LVM_ROOT="root"
  if [ "$PARTITION_LAYOUT" = "Encrypted" ]; then
    create_encrypted_layout
  else
    pvcreate -f $ROOT_PART &> /dev/null 
    vgcreate -f $LVM_GROUP $ROOT_PART &> /dev/null
    if $swap_enabled; then
      LVM_SWAP="swap"
      lvcreate -y -L $SWAP $LVM_GROUP -n $LVM_SWAP &> /dev/null 
      lvcreate -y -l 100%FREE $LVM_GROUP -n $LVM_ROOT &> /dev/null 
      mkswap "/dev/${LVM_GROUP}/${LVM_SWAP}" &> /dev/null
      swapon "/dev/${LVM_GROUP}/${LVM_SWAP}"
    else
      lvcreate -y -l 100%FREE $LVM_GROUP -n $LVM_ROOT &> /dev/null 
    fi

    case "$FILE_SYSTEM" in
      btrfs|xfs) mkfs."$FILE_SYSTEM" -f "/dev/${LVM_GROUP}/${LVM_ROOT}" \
                   &> /dev/null ;;
      *) mkfs."$FILE_SYSTEM" "/dev/${LVM_GROUP}/${LVM_ROOT}" &> /dev/null ;; 
    esac
    mount "/dev/${LVM_GROUP}/${LVM_ROOT}" /mnt
    if [ -d /sys/firmware/efi ]; then
      mkdir /mnt/boot
      mount $BOOT_PART /mnt/boot
    fi
  fi
}

# Set up LUKS on top of the LVM partition for root disk encryption
create_encrypted_layout() {
  inputs_match=false
  while ! $inputs_match; do
    input=$(dialog --title "Encrypt $ROOT_PART" --clear --stdout \
      --insecure --passwordbox "Enter a passphrase to encrypt \
$ROOT_PART.\n\nThe overall strength of the encryption process depends \
strongly on this passphrase, therefore you should set a passphrase that is \
not easy to guess.\n\nNote that the passphrase you enter will be required \
each time on boot.\n\nEncryption passphrase:" 15 80)

    if [ $? -eq 0 ]; then
      confirm_input=$(dialog --title "Encrypt $ROOT_PART" --clear --stdout \
        --insecure --passwordbox "Re-enter passphrase to verify:" 8 55)

      if [ -z "$input" ]; then
        dialog --title "ERROR: Empty Passphrase" \
          --msgbox "You are not allowed to have an empty passphrase." 5 55
      elif [ "$input" != "$confirm_input" ]; then
        dialog --title "ERROR: Passphrases Do No Match" \
          --msgbox "The two passphrases you entered did not match." 5 55
      elif [ "${#input}" -lt 8 ]; then
        dialog --title "WARNING: Weak Passphrase" --defaultno \
          --yesno "The passphrase you entered is less than 8 characters which \
is considered insecure.\n\nContinue using a weak passphrase?"  8 60
        if [ $? -eq 0 ]; then
          inputs_match=true
        fi
      else
        inputs_match=true
      fi
    else
      dialog --title "Revert Partition Changes" --defaultno \
        --yesno "Are you sure you want to cancel the encryption \
process? If you choose yes, you will be returned to the partition menu." 7 65
      if [ $? -eq 0 ]; then
        prepare_disk
      fi
    fi
  done

  CRYPT_DEVICE_NAME="cryptlvm"
  printf "$input" | cryptsetup luksFormat "$ROOT_PART" - &> /dev/null
  printf "$input" | cryptsetup open "$ROOT_PART" "$CRYPT_DEVICE_NAME" -
  pvcreate -f "/dev/mapper/${CRYPT_DEVICE_NAME}" &> /dev/null
  vgcreate -f "$LVM_GROUP" "/dev/mapper/${CRYPT_DEVICE_NAME}" &> /dev/null

  if $swap_enabled; then
    LVM_SWAP="swap"
    lvcreate -y -L $SWAP $LVM_GROUP -n $LVM_SWAP &> /dev/null 
    lvcreate -y -l 100%FREE $LVM_GROUP -n $LVM_ROOT &> /dev/null 
    mkswap "/dev/mapper/${LVM_GROUP}-${LVM_SWAP}" &> /dev/null
    swapon "/dev/mapper/${LVM_GROUP}-${LVM_SWAP}"
  else
    lvcreate -y -l 100%FREE $LVM_GROUP -n $LVM_ROOT &> /dev/null 
  fi

  case "$FILE_SYSTEM" in
    btrfs|xfs) mkfs."$FILE_SYSTEM" -f "/dev/mapper/${LVM_GROUP}-${LVM_ROOT}" \
                 &> /dev/null ;;
    *) mkfs."$FILE_SYSTEM" "/dev/mapper/${LVM_GROUP}-${LVM_ROOT}" \
                 &> /dev/null ;; 
  esac
  mount "/dev/mapper/${LVM_GROUP}-${LVM_ROOT}" /mnt
  if [ -d /sys/firmware/efi ]; then
    mkdir /mnt/boot
    mount $BOOT_PART /mnt/boot
  fi
}

# Menu which allows the user to navigate the installer
main_menu() {
  while true; do
    menu_choice=$(dialog --title "Arch Linux Installer Main Menu" --nocancel \
      --menu "Select an option below using the UP/DOWN keys and SPACE or \
ENTER.\nAlternate keys may also be used: '+', '-', and TAB." 17 70 9 \
"KEYMAP" "Set the keyboard layout" \
"LOCALE" "Set the system locale" \
"TIMEZONE" "Set the system time zone" \
"HOSTNAME" "Set the system's hostname" \
"ROOT PASSWORD" "Set the root password" \
"CREATE USER" "Create your user account" \
"PARTITION" "Partition the installation drive" \
"EXIT" "Exit Arch Linux Installer" 3>&1 1>&2 2>&3)

    case "$menu_choice" in
      "KEYMAP") set_keymap ;;
      "LOCALE") set_locale ;;
      "TIMEZONE") set_timezone ;;
      "HOSTNAME") set_hostname ;;
      "ROOT PASSWORD") set_root_passwd ;;
      "CREATE USER") create_user ;;
      "PARTITION") prepare_disk ;;
      "EXIT") reset ; exit ;;
    esac
  done
}

main() {
  check_connection
  set_keymap
  set_locale
  set_timezone
  set_hostname
  set_root_passwd
  create_user
  prepare_disk
}

main
